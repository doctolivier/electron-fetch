{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": ["/**\r\n * index.js\r\n *\r\n * a request API compatible with window.fetch\r\n */\r\n\r\nimport electron from \"electron\";\r\nimport { resolve as resolveURL } from \"url\";\r\nimport * as http from \"http\";\r\nimport * as https from \"https\";\r\nimport * as zlib from \"zlib\";\r\nimport { PassThrough } from \"stream\";\r\n\r\nimport { writeToStream, getNodeRequestOptions } from \"./common.js\";\r\nimport Response from \"./response.js\";\r\nimport Headers from \"./headers.js\";\r\nimport Request from \"./request.js\";\r\nimport FetchError from \"./fetch-error.js\";\r\nimport { FetchErrorType, RequestInit } from \"./types.js\";\r\n\r\nconst isReady =\r\n  electron && electron.app && !electron.app.isReady()\r\n    ? new Promise((resolve) => electron.app.once(\"ready\", resolve))\r\n    : Promise.resolve();\r\n\r\n/**\r\n * Fetch function\r\n *\r\n * @param {string|Request} url Absolute url or Request instance\r\n * @param {Object} [opts] Fetch options\r\n * @return {Promise}\r\n */\r\nexport default function fetch(url: string | Request, opts: RequestInit = {}) {\r\n  // wrap http.request into fetch\r\n  return isReady.then(\r\n    () =>\r\n      new Promise((resolve, reject) => {\r\n        // build request object\r\n        const request = new Request(url, opts);\r\n        const options = getNodeRequestOptions(request);\r\n\r\n        const send = request.useElectronNet\r\n          ? electron.net.request\r\n          : // @ts-ignore\r\n            (options.protocol === \"https:\" ? https : http).request;\r\n\r\n        // http.request only support string as host header, this hack make custom host header possible\r\n        if (options.headers.host) {\r\n          options.headers.host = options.headers.host[0];\r\n        }\r\n\r\n        if (request.signal && request.signal.aborted) {\r\n          reject(new FetchError(\"request aborted\", FetchErrorType.Abort));\r\n          return;\r\n        }\r\n\r\n        // send request\r\n        let headers;\r\n        if (request.useElectronNet) {\r\n          headers = options.headers;\r\n          delete options.headers;\r\n          // @ts-ignore\r\n          options.session = opts.session || electron.session.defaultSession;\r\n          // @ts-ignore\r\n          options.useSessionCookies = request.useSessionCookies;\r\n        } else {\r\n          // @ts-ignore\r\n          if (opts.agent) options.agent = opts.agent;\r\n          if (opts.onLogin)\r\n            reject(\r\n              new Error(\r\n                '\"onLogin\" option is only supported with \"useElectronNet\" enabled'\r\n              )\r\n            );\r\n        }\r\n        const req = send(options);\r\n        if (request.useElectronNet) {\r\n          for (const headerName in headers) {\r\n            if (typeof headers[headerName] === \"string\")\r\n              req.setHeader(headerName, headers[headerName]);\r\n            else {\r\n              for (const headerValue of headers[headerName]) {\r\n                req.setHeader(headerName, headerValue);\r\n              }\r\n            }\r\n          }\r\n        }\r\n        let reqTimeout: NodeJS.Timeout;\r\n\r\n        const cancelRequest = () => {\r\n          if (request.useElectronNet) {\r\n            req.abort(); // in electron, `req.destroy()` does not send abort to server\r\n          } else {\r\n            (req as http.ClientRequest).destroy(); // in node.js, `req.abort()` is deprecated\r\n          }\r\n        };\r\n        const abortRequest = () => {\r\n          const err = new FetchError(\"request aborted\", FetchErrorType.Abort);\r\n          reject(err);\r\n          cancelRequest();\r\n          req.emit(\"error\", err);\r\n        };\r\n\r\n        if (request.signal) {\r\n          request.signal.addEventListener(\"abort\", abortRequest);\r\n        }\r\n\r\n        if (request.timeout) {\r\n          reqTimeout = setTimeout(() => {\r\n            const err = new FetchError(\r\n              `network timeout at: ${request.url}`,\r\n              FetchErrorType.RequestTimeout\r\n            );\r\n            reject(err);\r\n            cancelRequest();\r\n          }, request.timeout);\r\n        }\r\n\r\n        if (request.useElectronNet) {\r\n          // handle authenticating proxies\r\n          req.on(\"login\", (authInfo: any, callback: Function) => {\r\n            if (opts.user && opts.password) {\r\n              callback(opts.user, opts.password);\r\n            } else if (opts.onLogin) {\r\n              opts\r\n                .onLogin(authInfo)\r\n                .then((credentials) => {\r\n                  if (credentials) {\r\n                    callback(credentials.username, credentials.password);\r\n                  } else {\r\n                    callback();\r\n                  }\r\n                })\r\n                .catch((error) => {\r\n                  cancelRequest();\r\n                  reject(error);\r\n                });\r\n            } else {\r\n              cancelRequest();\r\n              reject(\r\n                new FetchError(\r\n                  `login event received from ${authInfo.host} but no credentials or onLogin handler provided`,\r\n                  FetchErrorType.Proxy,\r\n                  { code: \"PROXY_AUTH_FAILED\" }\r\n                )\r\n              );\r\n            }\r\n          });\r\n        }\r\n\r\n        req.on(\"error\", (err: any) => {\r\n          clearTimeout(reqTimeout);\r\n          if (request.signal) {\r\n            request.signal.removeEventListener(\"abort\", abortRequest);\r\n          }\r\n\r\n          reject(\r\n            new FetchError(\r\n              `request to ${request.url} failed, reason: ${err.message}`,\r\n              FetchErrorType.System,\r\n              err\r\n            )\r\n          );\r\n        });\r\n\r\n        req.on(\"abort\", () => {\r\n          clearTimeout(reqTimeout);\r\n          if (request.signal) {\r\n            request.signal.removeEventListener(\"abort\", abortRequest);\r\n          }\r\n        });\r\n\r\n        req.on(\"response\", (res) => {\r\n          try {\r\n            clearTimeout(reqTimeout);\r\n            if (request.signal) {\r\n              request.signal.removeEventListener(\"abort\", abortRequest);\r\n            }\r\n\r\n            // handle redirect\r\n            if (\r\n              fetch.isRedirect(res.statusCode) &&\r\n              request.redirect !== \"manual\"\r\n            ) {\r\n              if (request.redirect === \"error\") {\r\n                reject(\r\n                  new FetchError(\r\n                    `redirect mode is set to error: ${request.url}`,\r\n                    FetchErrorType.NoRedirect\r\n                  )\r\n                );\r\n                return;\r\n              }\r\n\r\n              if (request.counter >= request.follow) {\r\n                reject(\r\n                  new FetchError(\r\n                    `maximum redirect reached at: ${request.url}`,\r\n                    FetchErrorType.MaxRedirect\r\n                  )\r\n                );\r\n                return;\r\n              }\r\n\r\n              if (!res.headers.location) {\r\n                reject(\r\n                  new FetchError(\r\n                    `redirect location header missing at: ${request.url}`,\r\n                    FetchErrorType.InvalidRedirect\r\n                  )\r\n                );\r\n                return;\r\n              }\r\n\r\n              // per fetch spec, for POST request with 301/302 response, or any request with 303 response, use GET when following redirect\r\n              if (\r\n                res.statusCode === 303 ||\r\n                ((res.statusCode === 301 || res.statusCode === 302) &&\r\n                  request.method === \"POST\")\r\n              ) {\r\n                request.method = \"GET\";\r\n                request.body = null;\r\n                request.headers && request.headers.delete(\"content-length\");\r\n              }\r\n\r\n              request.counter++;\r\n\r\n              resolve(\r\n                // @ts-ignore\r\n                fetch(resolveURL(request.url, res.headers.location), request)\r\n              );\r\n              return;\r\n            }\r\n\r\n            // normalize location header for manual redirect mode\r\n            const headers = new Headers();\r\n            for (const name of Object.keys(res.headers)) {\r\n              if (Array.isArray(res.headers[name])) {\r\n                for (const val of res.headers[name]) {\r\n                  headers.append(name, val);\r\n                }\r\n              } else {\r\n                headers.append(name, res.headers[name] || \"\");\r\n              }\r\n            }\r\n            if (request.redirect === \"manual\" && headers.has(\"location\")) {\r\n              headers.set(\r\n                \"location\",\r\n                resolveURL(request.url, headers.get(\"location\") || \"\")\r\n              );\r\n            }\r\n\r\n            // prepare response\r\n            let body = new PassThrough();\r\n            res.on(\"error\", (err) => body.emit(\"error\", err));\r\n            // @ts-ignore\r\n            res.pipe(body);\r\n            body.on(\"error\", cancelRequest);\r\n            body.on(\"cancel-request\", cancelRequest);\r\n\r\n            const abortBody = () => {\r\n              // @ts-ignore\r\n              res.destroy();\r\n              res.emit(\r\n                \"error\",\r\n                new FetchError(\"request aborted\", FetchErrorType.Abort)\r\n              ); // separated from the `.destroy()` because somehow Node's IncomingMessage streams do not emit errors on destroy\r\n            };\r\n\r\n            if (request.signal) {\r\n              request.signal.addEventListener(\"abort\", abortBody);\r\n              res.on(\"end\", () => {\r\n                request.signal.removeEventListener(\"abort\", abortBody);\r\n              });\r\n              res.on(\"error\", () => {\r\n                request.signal.removeEventListener(\"abort\", abortBody);\r\n              });\r\n            }\r\n\r\n            const responseOptions = {\r\n              url: request.url,\r\n              status: res.statusCode,\r\n              statusText: res.statusMessage,\r\n              headers,\r\n              size: request.size,\r\n              timeout: request.timeout,\r\n              useElectronNet: request.useElectronNet,\r\n              useSessionCookies: request.useSessionCookies,\r\n            };\r\n\r\n            // HTTP-network fetch step 16.1.2\r\n            const codings = headers.get(\"Content-Encoding\");\r\n\r\n            // HTTP-network fetch step 16.1.3: handle content codings\r\n\r\n            // in following scenarios we ignore compression support\r\n            // 1. running on Electron/net module (it manages it for us)\r\n            // 2. HEAD request\r\n            // 3. no Content-Encoding header\r\n            // 4. no content response (204)\r\n            // 5. content not modified response (304)\r\n            if (\r\n              !request.useElectronNet &&\r\n              request.method !== \"HEAD\" &&\r\n              codings !== null &&\r\n              res.statusCode !== 204 &&\r\n              res.statusCode !== 304\r\n            ) {\r\n              // Be less strict when decoding compressed responses, since sometimes\r\n              // servers send slightly invalid responses that are still accepted\r\n              // by common browsers.\r\n              // Always using Z_SYNC_FLUSH is what cURL does.\r\n              // /!\\ This is disabled for now, because it seems broken in recent node\r\n              // const zlibOptions = {\r\n              //   flush: zlib.Z_SYNC_FLUSH,\r\n              //   finishFlush: zlib.Z_SYNC_FLUSH\r\n              // }\r\n\r\n              if (codings === \"gzip\" || codings === \"x-gzip\") {\r\n                // for gzip\r\n                body = body.pipe(zlib.createGunzip());\r\n              } else if (codings === \"deflate\" || codings === \"x-deflate\") {\r\n                // for deflate\r\n                // handle the infamous raw deflate response from old servers\r\n                // a hack for old IIS and Apache servers\r\n                // @ts-ignore\r\n                const raw = res.pipe(new PassThrough());\r\n                return raw.once(\"data\", (chunk: any) => {\r\n                  // see http://stackoverflow.com/questions/37519828\r\n                  if ((chunk[0] & 0x0f) === 0x08) {\r\n                    body = body.pipe(zlib.createInflate());\r\n                  } else {\r\n                    body = body.pipe(zlib.createInflateRaw());\r\n                  }\r\n                  const response = new Response(body, responseOptions);\r\n                  resolve(response);\r\n                });\r\n              }\r\n            }\r\n\r\n            const response = new Response(body, responseOptions);\r\n            resolve(response);\r\n          } catch (error) {\r\n            reject(\r\n              new FetchError(\r\n                `Invalid response: ${error.message}`,\r\n                FetchErrorType.InvalidRedirect\r\n              )\r\n            );\r\n            cancelRequest();\r\n          }\r\n        });\r\n\r\n        writeToStream(req, request);\r\n      })\r\n  );\r\n}\r\n\r\n/**\r\n * Redirect code matching\r\n *\r\n * @param {number} code Status code\r\n * @return {boolean}\r\n */\r\nfetch.isRedirect = (code: number) =>\r\n  code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\r\n\r\nexport { Headers, Request, Response, FetchError };\r\n"],
  "mappings": "AAMA,OAAO,cAAc;AACrB,SAAS,WAAW,kBAAkB;AACtC,YAAY,UAAU;AACtB,YAAY,WAAW;AACvB,YAAY,UAAU;AACtB,SAAS,mBAAmB;AAE5B,SAAS,eAAe,6BAA6B;AACrD,OAAO,cAAc;AACrB,OAAO,aAAa;AACpB,OAAO,aAAa;AACpB,OAAO,gBAAgB;AACvB,SAAS,sBAAmC;AAE5C,MAAM,UACJ,YAAY,SAAS,OAAO,CAAC,SAAS,IAAI,QAAQ,IAC9C,IAAI,QAAQ,CAAC,YAAY,SAAS,IAAI,KAAK,SAAS,OAAO,CAAC,IAC5D,QAAQ,QAAQ;AASP,SAAR,MAAuB,KAAuB,OAAoB,CAAC,GAAG;AAE3E,SAAO,QAAQ;AAAA,IACb,MACE,IAAI,QAAQ,CAAC,SAAS,WAAW;AAE/B,YAAM,UAAU,IAAI,QAAQ,KAAK,IAAI;AACrC,YAAM,UAAU,sBAAsB,OAAO;AAE7C,YAAM,OAAO,QAAQ,iBACjB,SAAS,IAAI;AAAA;AAAA,SAEZ,QAAQ,aAAa,WAAW,QAAQ,MAAM;AAAA;AAGnD,UAAI,QAAQ,QAAQ,MAAM;AACxB,gBAAQ,QAAQ,OAAO,QAAQ,QAAQ,KAAK,CAAC;AAAA,MAC/C;AAEA,UAAI,QAAQ,UAAU,QAAQ,OAAO,SAAS;AAC5C,eAAO,IAAI,WAAW,mBAAmB,eAAe,KAAK,CAAC;AAC9D;AAAA,MACF;AAGA,UAAI;AACJ,UAAI,QAAQ,gBAAgB;AAC1B,kBAAU,QAAQ;AAClB,eAAO,QAAQ;AAEf,gBAAQ,UAAU,KAAK,WAAW,SAAS,QAAQ;AAEnD,gBAAQ,oBAAoB,QAAQ;AAAA,MACtC,OAAO;AAEL,YAAI,KAAK,MAAO,SAAQ,QAAQ,KAAK;AACrC,YAAI,KAAK;AACP;AAAA,YACE,IAAI;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,MACJ;AACA,YAAM,MAAM,KAAK,OAAO;AACxB,UAAI,QAAQ,gBAAgB;AAC1B,mBAAW,cAAc,SAAS;AAChC,cAAI,OAAO,QAAQ,UAAU,MAAM;AACjC,gBAAI,UAAU,YAAY,QAAQ,UAAU,CAAC;AAAA,eAC1C;AACH,uBAAW,eAAe,QAAQ,UAAU,GAAG;AAC7C,kBAAI,UAAU,YAAY,WAAW;AAAA,YACvC;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,UAAI;AAEJ,YAAM,gBAAgB,MAAM;AAC1B,YAAI,QAAQ,gBAAgB;AAC1B,cAAI,MAAM;AAAA,QACZ,OAAO;AACL,UAAC,IAA2B,QAAQ;AAAA,QACtC;AAAA,MACF;AACA,YAAM,eAAe,MAAM;AACzB,cAAM,MAAM,IAAI,WAAW,mBAAmB,eAAe,KAAK;AAClE,eAAO,GAAG;AACV,sBAAc;AACd,YAAI,KAAK,SAAS,GAAG;AAAA,MACvB;AAEA,UAAI,QAAQ,QAAQ;AAClB,gBAAQ,OAAO,iBAAiB,SAAS,YAAY;AAAA,MACvD;AAEA,UAAI,QAAQ,SAAS;AACnB,qBAAa,WAAW,MAAM;AAC5B,gBAAM,MAAM,IAAI;AAAA,YACd,uBAAuB,QAAQ,GAAG;AAAA,YAClC,eAAe;AAAA,UACjB;AACA,iBAAO,GAAG;AACV,wBAAc;AAAA,QAChB,GAAG,QAAQ,OAAO;AAAA,MACpB;AAEA,UAAI,QAAQ,gBAAgB;AAE1B,YAAI,GAAG,SAAS,CAAC,UAAe,aAAuB;AACrD,cAAI,KAAK,QAAQ,KAAK,UAAU;AAC9B,qBAAS,KAAK,MAAM,KAAK,QAAQ;AAAA,UACnC,WAAW,KAAK,SAAS;AACvB,iBACG,QAAQ,QAAQ,EAChB,KAAK,CAAC,gBAAgB;AACrB,kBAAI,aAAa;AACf,yBAAS,YAAY,UAAU,YAAY,QAAQ;AAAA,cACrD,OAAO;AACL,yBAAS;AAAA,cACX;AAAA,YACF,CAAC,EACA,MAAM,CAAC,UAAU;AAChB,4BAAc;AACd,qBAAO,KAAK;AAAA,YACd,CAAC;AAAA,UACL,OAAO;AACL,0BAAc;AACd;AAAA,cACE,IAAI;AAAA,gBACF,6BAA6B,SAAS,IAAI;AAAA,gBAC1C,eAAe;AAAA,gBACf,EAAE,MAAM,oBAAoB;AAAA,cAC9B;AAAA,YACF;AAAA,UACF;AAAA,QACF,CAAC;AAAA,MACH;AAEA,UAAI,GAAG,SAAS,CAAC,QAAa;AAC5B,qBAAa,UAAU;AACvB,YAAI,QAAQ,QAAQ;AAClB,kBAAQ,OAAO,oBAAoB,SAAS,YAAY;AAAA,QAC1D;AAEA;AAAA,UACE,IAAI;AAAA,YACF,cAAc,QAAQ,GAAG,oBAAoB,IAAI,OAAO;AAAA,YACxD,eAAe;AAAA,YACf;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AAED,UAAI,GAAG,SAAS,MAAM;AACpB,qBAAa,UAAU;AACvB,YAAI,QAAQ,QAAQ;AAClB,kBAAQ,OAAO,oBAAoB,SAAS,YAAY;AAAA,QAC1D;AAAA,MACF,CAAC;AAED,UAAI,GAAG,YAAY,CAAC,QAAQ;AAC1B,YAAI;AACF,uBAAa,UAAU;AACvB,cAAI,QAAQ,QAAQ;AAClB,oBAAQ,OAAO,oBAAoB,SAAS,YAAY;AAAA,UAC1D;AAGA,cACE,MAAM,WAAW,IAAI,UAAU,KAC/B,QAAQ,aAAa,UACrB;AACA,gBAAI,QAAQ,aAAa,SAAS;AAChC;AAAA,gBACE,IAAI;AAAA,kBACF,kCAAkC,QAAQ,GAAG;AAAA,kBAC7C,eAAe;AAAA,gBACjB;AAAA,cACF;AACA;AAAA,YACF;AAEA,gBAAI,QAAQ,WAAW,QAAQ,QAAQ;AACrC;AAAA,gBACE,IAAI;AAAA,kBACF,gCAAgC,QAAQ,GAAG;AAAA,kBAC3C,eAAe;AAAA,gBACjB;AAAA,cACF;AACA;AAAA,YACF;AAEA,gBAAI,CAAC,IAAI,QAAQ,UAAU;AACzB;AAAA,gBACE,IAAI;AAAA,kBACF,wCAAwC,QAAQ,GAAG;AAAA,kBACnD,eAAe;AAAA,gBACjB;AAAA,cACF;AACA;AAAA,YACF;AAGA,gBACE,IAAI,eAAe,QACjB,IAAI,eAAe,OAAO,IAAI,eAAe,QAC7C,QAAQ,WAAW,QACrB;AACA,sBAAQ,SAAS;AACjB,sBAAQ,OAAO;AACf,sBAAQ,WAAW,QAAQ,QAAQ,OAAO,gBAAgB;AAAA,YAC5D;AAEA,oBAAQ;AAER;AAAA;AAAA,cAEE,MAAM,WAAW,QAAQ,KAAK,IAAI,QAAQ,QAAQ,GAAG,OAAO;AAAA,YAC9D;AACA;AAAA,UACF;AAGA,gBAAMA,WAAU,IAAI,QAAQ;AAC5B,qBAAW,QAAQ,OAAO,KAAK,IAAI,OAAO,GAAG;AAC3C,gBAAI,MAAM,QAAQ,IAAI,QAAQ,IAAI,CAAC,GAAG;AACpC,yBAAW,OAAO,IAAI,QAAQ,IAAI,GAAG;AACnC,gBAAAA,SAAQ,OAAO,MAAM,GAAG;AAAA,cAC1B;AAAA,YACF,OAAO;AACL,cAAAA,SAAQ,OAAO,MAAM,IAAI,QAAQ,IAAI,KAAK,EAAE;AAAA,YAC9C;AAAA,UACF;AACA,cAAI,QAAQ,aAAa,YAAYA,SAAQ,IAAI,UAAU,GAAG;AAC5D,YAAAA,SAAQ;AAAA,cACN;AAAA,cACA,WAAW,QAAQ,KAAKA,SAAQ,IAAI,UAAU,KAAK,EAAE;AAAA,YACvD;AAAA,UACF;AAGA,cAAI,OAAO,IAAI,YAAY;AAC3B,cAAI,GAAG,SAAS,CAAC,QAAQ,KAAK,KAAK,SAAS,GAAG,CAAC;AAEhD,cAAI,KAAK,IAAI;AACb,eAAK,GAAG,SAAS,aAAa;AAC9B,eAAK,GAAG,kBAAkB,aAAa;AAEvC,gBAAM,YAAY,MAAM;AAEtB,gBAAI,QAAQ;AACZ,gBAAI;AAAA,cACF;AAAA,cACA,IAAI,WAAW,mBAAmB,eAAe,KAAK;AAAA,YACxD;AAAA,UACF;AAEA,cAAI,QAAQ,QAAQ;AAClB,oBAAQ,OAAO,iBAAiB,SAAS,SAAS;AAClD,gBAAI,GAAG,OAAO,MAAM;AAClB,sBAAQ,OAAO,oBAAoB,SAAS,SAAS;AAAA,YACvD,CAAC;AACD,gBAAI,GAAG,SAAS,MAAM;AACpB,sBAAQ,OAAO,oBAAoB,SAAS,SAAS;AAAA,YACvD,CAAC;AAAA,UACH;AAEA,gBAAM,kBAAkB;AAAA,YACtB,KAAK,QAAQ;AAAA,YACb,QAAQ,IAAI;AAAA,YACZ,YAAY,IAAI;AAAA,YAChB,SAAAA;AAAA,YACA,MAAM,QAAQ;AAAA,YACd,SAAS,QAAQ;AAAA,YACjB,gBAAgB,QAAQ;AAAA,YACxB,mBAAmB,QAAQ;AAAA,UAC7B;AAGA,gBAAM,UAAUA,SAAQ,IAAI,kBAAkB;AAU9C,cACE,CAAC,QAAQ,kBACT,QAAQ,WAAW,UACnB,YAAY,QACZ,IAAI,eAAe,OACnB,IAAI,eAAe,KACnB;AAWA,gBAAI,YAAY,UAAU,YAAY,UAAU;AAE9C,qBAAO,KAAK,KAAK,KAAK,aAAa,CAAC;AAAA,YACtC,WAAW,YAAY,aAAa,YAAY,aAAa;AAK3D,oBAAM,MAAM,IAAI,KAAK,IAAI,YAAY,CAAC;AACtC,qBAAO,IAAI,KAAK,QAAQ,CAAC,UAAe;AAEtC,qBAAK,MAAM,CAAC,IAAI,QAAU,GAAM;AAC9B,yBAAO,KAAK,KAAK,KAAK,cAAc,CAAC;AAAA,gBACvC,OAAO;AACL,yBAAO,KAAK,KAAK,KAAK,iBAAiB,CAAC;AAAA,gBAC1C;AACA,sBAAMC,YAAW,IAAI,SAAS,MAAM,eAAe;AACnD,wBAAQA,SAAQ;AAAA,cAClB,CAAC;AAAA,YACH;AAAA,UACF;AAEA,gBAAM,WAAW,IAAI,SAAS,MAAM,eAAe;AACnD,kBAAQ,QAAQ;AAAA,QAClB,SAAS,OAAO;AACd;AAAA,YACE,IAAI;AAAA,cACF,qBAAqB,MAAM,OAAO;AAAA,cAClC,eAAe;AAAA,YACjB;AAAA,UACF;AACA,wBAAc;AAAA,QAChB;AAAA,MACF,CAAC;AAED,oBAAc,KAAK,OAAO;AAAA,IAC5B,CAAC;AAAA,EACL;AACF;AAQA,MAAM,aAAa,CAAC,SAClB,SAAS,OAAO,SAAS,OAAO,SAAS,OAAO,SAAS,OAAO,SAAS;",
  "names": ["headers", "response"]
}
