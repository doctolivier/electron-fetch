{
  "version": 3,
  "sources": ["../../src/types.ts"],
  "sourcesContent": ["import { Stream } from \"node:stream\";\r\nimport { Agent } from \"node:https\";\r\nimport { AuthInfo, Session } from \"electron\";\r\n\r\nimport Blob from \"./blob.js\";\r\n\r\n// BODY TYPES\r\nexport type BodyInit = Stream | string | Blob | Buffer | null;\r\n\r\n// FETCH TYPES\r\nexport enum FetchErrorType {\r\n  BodyTimeout = \"body-timeout\",\r\n  System = \"system\",\r\n  MaxSize = \"max-size\",\r\n  Abort = \"abort\",\r\n  RequestTimeout = \"request-timeout\",\r\n  Proxy = \"proxy\",\r\n  NoRedirect = \"no-redirect\",\r\n  MaxRedirect = \"max-redirect\",\r\n  InvalidRedirect = \"invalid-redirect\",\r\n}\r\n\r\nexport const netErrorMap = {\r\n  ERR_CONNECTION_REFUSED: \"ECONNREFUSED\",\r\n  ERR_EMPTY_RESPONSE: \"ECONNRESET\",\r\n  ERR_NAME_NOT_RESOLVED: \"ENOTFOUND\",\r\n  ERR_CONTENT_DECODING_FAILED: \"Z_DATA_ERROR\",\r\n  ERR_CONTENT_DECODING_INIT_FAILED: \"Z_DATA_ERROR\",\r\n  ERR_UNKNOW: \"UNKNOWN\",\r\n};\r\n\r\nexport type NetErrorType = keyof typeof netErrorMap;\r\n\r\nexport interface RequestInit {\r\n  // These properties are part of the Fetch Standard\r\n  counter?: number;\r\n  method?: string;\r\n  headers?: HeadersInit;\r\n  body?: BodyInit;\r\n  signal?: AbortSignal;\r\n  // (/!\\ only works when running on Node.js) set to `manual` to extract redirect headers, `error` to reject redirect\r\n  redirect?: RequestRedirect;\r\n\r\n  ////////////////////////////////////////////////////////////////////////////\r\n  // The following properties are electron-fetch extensions\r\n  // (/!\\ only works when running on Node.js) maximum redirect count. 0 to not follow redirect\r\n  follow?: number;\r\n  // req/res timeout in ms, it resets on redirect. 0 to disable (OS limit applies)\r\n  timeout?: number;\r\n  // maximum response body size in bytes. 0 to disable\r\n  size?: number;\r\n  session?: Session;\r\n  agent?: Agent;\r\n  useElectronNet?: boolean;\r\n  useSessionCookies?: boolean;\r\n  // When running on Electron behind an authenticated HTTP proxy, username to use to authenticate\r\n  user?: string;\r\n  // When running on Electron behind an authenticated HTTP proxy, password to use to authenticate\r\n  password?: string;\r\n  /**\r\n   * When running on Electron behind an authenticated HTTP proxy, handler of `electron.ClientRequest`'s `login` event.\r\n   * Can be used for acquiring proxy credentials in an async manner (e.g. prompting the user).\r\n   */\r\n  onLogin?: (\r\n    authInfo: AuthInfo\r\n  ) => Promise<{ username: string; password: string } | undefined>;\r\n}\r\n\r\nexport interface ResponseInit {\r\n  ok?: boolean;\r\n  url?: string;\r\n  status?: number;\r\n  statusText?: string;\r\n  headers?: HeadersInit;\r\n  useElectronNet?: boolean;\r\n}\r\n"],
  "mappings": "AAUO,IAAK,iBAAL,kBAAKA,oBAAL;AACL,EAAAA,gBAAA,iBAAc;AACd,EAAAA,gBAAA,YAAS;AACT,EAAAA,gBAAA,aAAU;AACV,EAAAA,gBAAA,WAAQ;AACR,EAAAA,gBAAA,oBAAiB;AACjB,EAAAA,gBAAA,WAAQ;AACR,EAAAA,gBAAA,gBAAa;AACb,EAAAA,gBAAA,iBAAc;AACd,EAAAA,gBAAA,qBAAkB;AATR,SAAAA;AAAA,GAAA;AAYL,MAAM,cAAc;AAAA,EACzB,wBAAwB;AAAA,EACxB,oBAAoB;AAAA,EACpB,uBAAuB;AAAA,EACvB,6BAA6B;AAAA,EAC7B,kCAAkC;AAAA,EAClC,YAAY;AACd;",
  "names": ["FetchErrorType"]
}
