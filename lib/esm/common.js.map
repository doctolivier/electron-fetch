{
  "version": 3,
  "sources": ["../../src/common.ts"],
  "sourcesContent": ["import { Stream, PassThrough } from \"node:stream\";\r\nimport http from \"node:http\";\r\nimport iconv from \"iconv-lite\";\r\n\r\nimport { BodyInit } from \"./types.js\";\r\nimport type Response from \"./response.js\";\r\nimport type Request from \"./request.js\";\r\n\r\n/**\r\n * Verifies that the given val is a valid HTTP token\r\n * per the rules defined in RFC 7230\r\n * See https://tools.ietf.org/html/rfc7230#section-3.2.6\r\n *\r\n * Allowed characters in an HTTP token:\r\n * ^_`a-z  94-122\r\n * A-Z     65-90\r\n * -       45\r\n * 0-9     48-57\r\n * !       33\r\n * #$%&'   35-39\r\n * *+      42-43\r\n * .       46\r\n * |       124\r\n * ~       126\r\n *\r\n * This implementation of checkIsHttpToken() loops over the string instead of\r\n * using a regular expression since the former is up to 180% faster with v8 4.9\r\n * depending on the string length (the shorter the string, the larger the\r\n * performance difference)\r\n *\r\n * Additionally, checkIsHttpToken() is currently designed to be inlinable by v8,\r\n * so take care when making changes to the implementation so that the source\r\n * code size does not exceed v8's default max_inlined_source_size setting.\r\n **/\r\nfunction isValidTokenChar(ch: number): boolean {\r\n  if (ch >= 94 && ch <= 122) {\r\n    return true;\r\n  }\r\n  if (ch >= 65 && ch <= 90) {\r\n    return true;\r\n  }\r\n  if (ch === 45) {\r\n    return true;\r\n  }\r\n  if (ch >= 48 && ch <= 57) {\r\n    return true;\r\n  }\r\n  if (ch === 34 || ch === 40 || ch === 41 || ch === 44) {\r\n    return false;\r\n  }\r\n  if (ch >= 33 && ch <= 46) {\r\n    return true;\r\n  }\r\n  if (ch === 124 || ch === 126) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function checkIsHttpToken(val: string): boolean {\r\n  if (typeof val !== \"string\" || val.length === 0) {\r\n    return false;\r\n  }\r\n  if (!isValidTokenChar(val.charCodeAt(0))) {\r\n    return false;\r\n  }\r\n  const len = val.length;\r\n  if (len > 1) {\r\n    if (!isValidTokenChar(val.charCodeAt(1))) {\r\n      return false;\r\n    }\r\n    if (len > 2) {\r\n      if (!isValidTokenChar(val.charCodeAt(2))) {\r\n        return false;\r\n      }\r\n      if (len > 3) {\r\n        if (!isValidTokenChar(val.charCodeAt(3))) {\r\n          return false;\r\n        }\r\n        for (let i = 4; i < len; i++) {\r\n          if (!isValidTokenChar(val.charCodeAt(i))) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * True if val contains an invalid field-vchar\r\n *  field-value    = *( field-content / obs-fold )\r\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\r\n *  field-vchar    = VCHAR / obs-text\r\n *\r\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\r\n * so take care when making changes to the implementation so that the source\r\n * code size does not exceed v8's default max_inlined_source_size setting.\r\n **/\r\nexport function checkInvalidHeaderChar(val: string): boolean {\r\n  val = String(val);\r\n  if (val.length < 1) {\r\n    return false;\r\n  }\r\n  let c = val.charCodeAt(0);\r\n  if ((c <= 31 && c !== 9) || c > 255 || c === 127) {\r\n    return true;\r\n  }\r\n  if (val.length < 2) {\r\n    return false;\r\n  }\r\n  c = val.charCodeAt(1);\r\n  if ((c <= 31 && c !== 9) || c > 255 || c === 127) {\r\n    return true;\r\n  }\r\n  if (val.length < 3) {\r\n    return false;\r\n  }\r\n  c = val.charCodeAt(2);\r\n  if ((c <= 31 && c !== 9) || c > 255 || c === 127) {\r\n    return true;\r\n  }\r\n  for (let i = 3; i < val.length; ++i) {\r\n    c = val.charCodeAt(i);\r\n    if ((c <= 31 && c !== 9) || c > 255 || c === 127) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function sanitizeName(name: string): string {\r\n  name = String(name);\r\n  if (!checkIsHttpToken(name)) {\r\n    throw new TypeError(`${name} is not a legal HTTP header name`);\r\n  }\r\n  return name.toLowerCase();\r\n}\r\n\r\nexport function sanitizeValue(value: string): string {\r\n  value = String(value);\r\n  if (checkInvalidHeaderChar(value)) {\r\n    throw new TypeError(`${value} is not a legal HTTP header value`);\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * Converts charset name if needed\r\n *\r\n * @param {String} name Character set\r\n * @return {String} Character set name\r\n */\r\nfunction checkEncoding(name: string) {\r\n  return (name || \"\")\r\n    .toString()\r\n    .trim()\r\n    .replace(/^latin[\\-_]?(\\d+)$/i, \"ISO-8859-$1\")\r\n    .replace(/^win(?:dows)?[\\-_]?(\\d+)$/i, \"WINDOWS-$1\")\r\n    .replace(/^utf[\\-_]?(\\d+)$/i, \"UTF-$1\")\r\n    .replace(/^ks_c_5601\\-1987$/i, \"CP949\")\r\n    .replace(/^us[\\-_]?ascii$/i, \"ASCII\")\r\n    .toUpperCase();\r\n}\r\n\r\n/**\r\n * Convert encoding of an UTF-8 string or a buffer\r\n *\r\n * @param {String|Buffer} str String to be converted\r\n * @param {String} to Encoding to be converted to\r\n * @param {String} [from='UTF-8'] Encoding to be converted from\r\n * @return {Buffer} Encoded string\r\n */\r\nexport function convert(\r\n  str: string | Buffer = \"\",\r\n  to: string,\r\n  from: string\r\n): Buffer {\r\n  from = checkEncoding(from || \"UTF-8\");\r\n  to = checkEncoding(to || \"UTF-8\");\r\n\r\n  let result;\r\n\r\n  if (from !== \"UTF-8\" && typeof str === \"string\") {\r\n    str = Buffer.from(str, \"binary\");\r\n  }\r\n\r\n  if (from === to) {\r\n    if (typeof str === \"string\") {\r\n      result = Buffer.from(str);\r\n    } else {\r\n      result = str;\r\n    }\r\n  } else {\r\n    try {\r\n      if (to === \"UTF-8\") {\r\n        result = iconv.decode(str as Buffer, from);\r\n      } else if (from === \"UTF-8\") {\r\n        result = iconv.encode(str as string, to);\r\n      } else {\r\n        result = iconv.encode(iconv.decode(str as Buffer, from), to);\r\n      }\r\n    } catch (err) {\r\n      console.error(err);\r\n      result = str;\r\n    }\r\n  }\r\n\r\n  if (typeof result === \"string\") {\r\n    result = Buffer.from(result, \"utf-8\");\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Clone body given Res/Req instance\r\n *\r\n * @param {Response|Request} instance Response or Request instance\r\n * @return {string|Blob|Buffer|Stream}\r\n */\r\nexport function clone(instance: Response | Request): BodyInit {\r\n  let p1, p2;\r\n  let body = instance.body;\r\n\r\n  // don't allow cloning a used body\r\n  if (instance.bodyUsed) {\r\n    throw new Error(\"cannot clone body after it is used\");\r\n  }\r\n\r\n  // check that body is a stream and not form-data object\r\n  // note: we can't clone the form-data object without having it as a dependency\r\n  if (\r\n    body instanceof Stream &&\r\n    typeof (body as any).getBoundary !== \"function\"\r\n  ) {\r\n    // tee instance body\r\n    p1 = new PassThrough();\r\n    p2 = new PassThrough();\r\n    body.pipe(p1);\r\n    body.pipe(p2);\r\n    // set instance body to teed body and return the other teed body\r\n    instance.body = p1;\r\n    body = p2;\r\n  }\r\n\r\n  return body as BodyInit;\r\n}\r\n\r\n/**\r\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\r\n * specified in the specification:\r\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\r\n *\r\n * This function assumes that instance.body is present and non-null.\r\n *\r\n * @param {Response|Request} instance Response or Request instance\r\n */\r\nexport function extractContentType(instance: Response | Request) {\r\n  const { body } = instance;\r\n\r\n  // istanbul ignore if: Currently, because of a guard in Request, body\r\n  // can never be null. Included here for completeness.\r\n  if (body === null) {\r\n    // body is null\r\n    return null;\r\n  } else if (typeof body === \"string\") {\r\n    // body is string\r\n    return \"text/plain;charset=UTF-8\";\r\n  } else if (body instanceof Blob) {\r\n    // body is blob\r\n    return body.type || null;\r\n  } else if (Buffer.isBuffer(body)) {\r\n    // body is buffer\r\n    return null;\r\n    // @ts-ignore\r\n  } else if (typeof body.getBoundary === \"function\") {\r\n    // detect form data input from form-data module\r\n    // @ts-ignore\r\n    return `multipart/form-data;boundary=${body.getBoundary()}`;\r\n  } else {\r\n    // body is stream\r\n    // can't really do much about this\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function getTotalBytes(instance: Response | Request) {\r\n  const { body } = instance;\r\n\r\n  // istanbul ignore if: included for completion\r\n  if (body === null) {\r\n    // body is null\r\n    return 0;\r\n  } else if (typeof body === \"string\") {\r\n    // body is string\r\n    return Buffer.byteLength(body);\r\n  } else if (body instanceof Blob) {\r\n    // body is blob\r\n    return body.size;\r\n  } else if (Buffer.isBuffer(body)) {\r\n    // body is buffer\r\n    return body.length;\r\n    // @ts-ignore\r\n  } else if (body && typeof body.getLengthSync === \"function\") {\r\n    // detect form data input from form-data module\r\n    // istanbul ignore next\r\n    if (\r\n      // @ts-ignore\r\n      (body._lengthRetrievers && body._lengthRetrievers.length === 0) || // 1.x\r\n      // @ts-ignore\r\n      (body.hasKnownLength && body.hasKnownLength())\r\n    ) {\r\n      // 2.x\r\n      // @ts-ignore\r\n      return body.getLengthSync();\r\n    }\r\n    return null;\r\n  } else {\r\n    // body is stream\r\n    // can't really do much about this\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function writeToStream(\r\n  dest: http.ClientRequest | Electron.ClientRequest,\r\n  instance: Response | Request\r\n) {\r\n  const { body } = instance;\r\n\r\n  if (body === null) {\r\n    // body is null\r\n    dest.end();\r\n  } else if (typeof body === \"string\") {\r\n    // body is string\r\n    dest.write(body);\r\n    dest.end();\r\n  } else if (body instanceof Blob) {\r\n    // body is blob\r\n    // @ts-ignore\r\n    dest.write(body.buffer);\r\n    dest.end();\r\n  } else if (Buffer.isBuffer(body)) {\r\n    // body is buffer\r\n    dest.write(body);\r\n    dest.end();\r\n  } else {\r\n    // body is stream\r\n    // @ts-ignore\r\n    if (instance.useElectronNet) {\r\n      // @ts-ignore\r\n      dest.chunkedEncoding = instance.chunkedEncoding;\r\n\r\n      // Force a first write to start the request otherwise an empty body stream\r\n      // will cause an error when closing the dest stream with Electron v7.\r\n      dest.write(\"\");\r\n    }\r\n    body\r\n      // @ts-ignore\r\n      .pipe(new PassThrough()) // I have to put a PassThrough because somehow, FormData streams are not eaten by electron/net\r\n      .pipe(dest);\r\n  }\r\n}\r\n\r\nexport function getNodeRequestOptions(request: Request) {\r\n  const parsedURL = request.url;\r\n  const headers = new Headers(request.headers);\r\n\r\n  // fetch step 3\r\n  if (!headers.has(\"Accept\")) {\r\n    headers.set(\"Accept\", \"*/*\");\r\n  }\r\n\r\n  // Basic fetch\r\n  // @ts-ignore\r\n  if (!parsedURL.protocol || !parsedURL.hostname) {\r\n    throw new TypeError(\"Only absolute URLs are supported\");\r\n  }\r\n\r\n  // @ts-ignore\r\n  if (!/^https?:$/.test(parsedURL.protocol)) {\r\n    throw new TypeError(\"Only HTTP(S) protocols are supported\");\r\n  }\r\n\r\n  // HTTP-network-or-cache fetch steps 5-9\r\n  let contentLengthValue = null;\r\n  if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\r\n    contentLengthValue = \"0\";\r\n  }\r\n  if (request.body != null) {\r\n    const totalBytes = getTotalBytes(request);\r\n    if (typeof totalBytes === \"number\") {\r\n      contentLengthValue = String(totalBytes);\r\n    }\r\n  }\r\n  if (contentLengthValue) {\r\n    if (!request.useElectronNet)\r\n      headers.set(\"Content-Length\", contentLengthValue);\r\n  } else {\r\n    request.chunkedEncoding = true;\r\n  }\r\n\r\n  // HTTP-network-or-cache fetch step 12\r\n  if (!headers.has(\"User-Agent\")) {\r\n    headers.set(\r\n      \"User-Agent\",\r\n      `electron-fetch/1.0 ${\r\n        request.useElectronNet ? \"electron\" : \"node\"\r\n      } (+https://github.com/arantes555/electron-fetch)`\r\n    );\r\n  }\r\n\r\n  // HTTP-network-or-cache fetch step 16\r\n  headers.set(\"Accept-Encoding\", \"gzip,deflate\");\r\n\r\n  // HTTP-network fetch step 4\r\n  // chunked encoding is handled by Node.js when not running in electron\r\n\r\n  return Object.assign({}, parsedURL, {\r\n    method: request.method,\r\n    // @ts-ignore\r\n    headers: headers.raw(),\r\n  });\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
